---
layout: post
title:  "What exactly are functors?"
date:   2024-02-03 22:00:00 -0300
categories: tech
---
{% include mathjax.html %}

A functor in category theory, a relatively modern branch of mathematics, is a mapping between 
categories. Categories consist of objects and their relations to each other called morphisms.

Suppose we have a category C1 which contains objects A and B, and
a morphism `f` between them. Similarly, consider a C2 category 
holding objects X and Y. Applying a functor `F` from 
C1 to C2 would mean creating a mapping from the objects and morphisms of C1 
to those of C2. So we would have: 

- `A` from C1 mapped to `X` in C2 through `F(A)`
- `B` from C1 mapped to `Y` in C2 through `F(B)`
- the morphism $$ f: A \rightarrow B $$ in C1 to  $$ F(f): F(A) \rightarrow F(B) $$ in C2

How the mapping is defined is very complicated and beyond 
this article's goal and my understanding. In a nutshell, it must
preserve the identiy of the morphisms and their compositions.
You can read more on that on the [Haskell wiki][haskell-functor-laws].

What I propose here is to show
you what functors are in programming and how useful they can be for **writing
declarative, concise code**. Let's analyze a Haskell example:

```haskell
data Box a = Box a deriving (Show)

instance Functor Box where
    fmap f (Box x) = Box (f x)

main :: IO ()
main = do
    let box = Box 5
    let newBox = fmap (*0.5) box
```

This code defines a custom data type `Box` which takes a 
single type parameter value of any type.
This isn't very special. What's interesting is the definition of a 
`Functor` instance for our data type: this typeclass allows 
the **application of a function over a container**.

The cool thing about this is that you can transform/generate new data,
without:

- changing the original data, which might lead to side effects, and,
at its worse, undefined behavior.
- having to understand, extract and rewrap the transformed data into its original context.

What makes this possible is the instance's implementation of `fmap`: under the hood,
it takes a function and a `Functor`, 
deconstructs the latter to get its associated parameter `x`,
applies the passed function `f` to it and wraps the result back in a `Box`. This 
keeps the context maintaing logic to that particular piece of code.

The code snippet highlights some core functional programming
concepts that allow you, a programmer, to focus on what you want to do 
with the data, rather than how to access or store it:

- **Immutability**: 
Haskell, like most purely functional programming languages, assumes data
to be constant; unchangeable.

- **Functions as first-class citizens**: 
This guideline enforces declarative, rather than imperative, code.
In some scenarios, this can be more readable especially for
software which performs multiple, advanced transformations on data.

In summary, functors aren't just an [alien, abstract mathematical concept][math-functor],
but a powerful tool in the functional programming paradigm.
By adopting them in your code, data operations,
regardless of how complex they are, will be more readable and expressive.


[math-functor]: (https://en.wikipedia.org/wiki/Functor)
[haskell-functor-laws]: (https://wiki.haskell.org/Functor#Functor_Laws)